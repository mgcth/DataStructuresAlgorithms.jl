"""
    NKeyType

Keys can hold value of type T or nothing.
"""
NKeyType = Union{T, Nothing} where T

"""
    BNode

Binary node.
"""
mutable struct BNode{T}
    key::NKeyType{T}
    left::BNode{T}
    right::BNode{T}
    BNode{T}() where T = (x = new(); x)
    BNode{T}(key) where T = (x = new(); x.key = key; x)
    BNode{T}(key, left, right) where T = new(key, left, right)
end

"""
    RMHeap

Randomised meldable heaps type.
"""
mutable struct RMHeap{T}
    root::BNode{T}
    RMHeap{T}() where T = new(BNode{T}())
end

"""
    add!(rmheap, x)

Add to the heap.
"""
function add!(rmheap::RMHeap{T}, x::T) where T
    rmheap.root = meld(rmheap.root, BNode{T}(x))
    return nothing
end

"""
    remove(rmheap)

Remove minimum element from the heap.
"""
function remove!(rmheap::RMHeap{T}) where T
    x = rmheap.root.key
    if !isdefined(rmheap, :left)
        rmheap = rmheap.root.right
        return x
    end
    if !isdefined(rmheap, :right)
        rmheap = rmheap.root.left
        return x
    end
    meld!(rmheap.root.left, rmheap.root.right)

    return x
end

"""
    meld!(rmheap, other)

Meld two heaps.
"""
function meld!(rmheap::RMHeap{T}, other::RMHeap{T}) where T
    rmheap.root = meld(rmheap.root, other.root)
    other.root = BNode{T}()
    return nothing
end

"""
    meld(node1, node2)

Meld two nodes.
"""
function meld(node1::BNode{T}, node2::BNode{T}) where T
    if node1.key == nothing return node2 end
    if node2.key == nothing return node1 end

    if node1.key > node2.key
        tmp = node1
        node1 = node2
        node2 = tmp
    end

    if rand((0, 1)) == 1
        if !isdefined(node1, :left) node1.left = BNode{T}() end
        node1.left = meld(node1.left, node2)
    else
        if !isdefined(node1, :right) node1.right = BNode{T}() end
        node1.right = meld(node1.right, node2)
    end

    return node1
end

"""
    getmin(rmheap)

Get the minimum element, don't remove.
"""
getmin(rmheap::RMHeap) = rmheap.root

"""
    iterate(rmheap, n)

Iterate over a linked list.
"""
# function iterate(rmheap::RMHeap, n = rmheap.root)
#     n == n.next ? nothing : (n.value, n.next)
# end

"""
    eltype(type)

Type of elements generated by iteration over a linked list.
"""
eltype(::RMHeap{T}) where T = T

"""
    MinPQ

Binary heap minimum priority queue.
"""
mutable struct MinPQ{T}
    pq::Vector{T}
    N::Int
    MinPQ{T}(n::Int) where T = new(Vector{T}(undef, n), n)
    MinPQ{T}() where T = new(Vector{T}(undef, 0), 0)
end

"""
    add(pq, x)

Add element to the priority queue.
"""
function add!(pq::MinPQ{T}, x::T) where T
    pq.N += 1
    push!(pq.pq, x)
    swim!(pq, pq.N)

    return nothing
end

"""
    removemin(pq)

Remove and get the smallst element from the priority queue.
"""
function removem!(pq::MinPQ)
    min = pq.pq[1]
    pq.pq[1] = pq.pq[pq.N]
    pq.pq[pq.N] = min
    pop!(pq.pq)
    pq.N -= 1
    sink(pq, 1)

    return min
end

"""
    swim!(pq)

Increase an elements priority in the priority queue.
"""
function swim!(pq::MinPQ, k::Int)
    while k > 1 && greater(pq, k รท 2, k)
        tmp = pq.pq[k รท 2]
        pq.pq[k รท 2] = pq.pq[k]
        pq.pq[k] = tmp
        k = k รท 2  
    end

    return nothing
end

"""
    sink!(pq, k)

Lower a node in the priority queue.
"""
function sink!(pq::MinPQ, k::Int)
    while 2k <= pq.N
        j = 2k
        if j < pq.N && greater(pq, j, j + 1) j += 1 end
        if !greater(pq, k, j) break end
        tmp = pq.pq[k]
        pq.pq[k] = pq.pq[j]
        pq.pq[j] = tmp
        k = j
    end

    return nothing
end

"""
    isempty(pq)

Check if priority queue is empty.
"""
isempty(pq::MinPQ) = pq.N == 0

"""
    getmin(pq)

Get the smallest element from priority queue, don't remove.
"""
getmin(pq::MinPQ) = pq.pq[1]

"""
    greater(pq, i, j)

Check if element i is larger than elemtn j in priority queue.
"""
greater(pq::MinPQ, i::Int, j::Int) = pq.pq[i] > pq.pq[j]